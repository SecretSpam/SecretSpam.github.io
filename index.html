const express = require('express');
const fetch = (...args) => import('node-fetch').then(({ default: fetch }) => fetch(...args));
const cors = require('cors');
const os = require('os');
const { JSDOM } = require('jsdom');

const app = express();
const port = process.env.PORT || 3000;

let loops = {};

app.use(cors());
app.use(express.json());

app.use((req, res, next) => {
  res.on('finish', () => {
    const interfaces = os.networkInterfaces();
    for (const iface of Object.values(interfaces)) {
      for (const ifaceDetails of iface) {
        if (ifaceDetails.family === 'IPv4' && !ifaceDetails.internal) {
          console.log(`Server IP: ${ifaceDetails.address}`);
        }
      }
    }
  });
  next();
});

const postData = (message, name, token) => {
  fetch('https://secret-share.net/play/action.php', {
    method: 'POST',
    headers: {
      'accept': '*/*',
      'accept-language': 'en-US,en;q=0.9,ru;q=0.8',
      'cache-control': 'no-cache',
      'content-type': 'application/x-www-form-urlencoded; charset=UTF-8',
      'cookie': 'secret_id=13127; secret_token=xB0rCCuz6h3ogNubCi5fF5LBH; secret_password=y7VwFlzErAWOz98K0Kow2ItbG; secret_user_agent=Mozilla/5.0%20(Windows%20NT%2010.0;%20Win64;%20x64)%20AppleWebKit/537.36%20(KHTML,%20like%20Gecko)%20Chrome/126.0.0.0%20Safari/537.36; PHPSESSID=ouvrk1221sbnq7edm99hjg0166',
      'origin': 'https://secret-share.net',
      'pragma': 'no-cache',
      'priority': 'u=1, i',
      'referer': 'https://secret-share.net/play/message.php?u=xB0rCCuz6h3ogNubCi5fF5LBH&n=13127',
      'sec-ch-ua': '"Not/A)Brand";v="8", "Chromium";v="126", "Google Chrome";v="126"',
      'sec-ch-ua-mobile': '?0',
      'sec-ch-ua-platform': '"Windows"',
      'sec-fetch-dest': 'empty',
      'sec-fetch-mode': 'cors',
      'sec-fetch-site': 'same-origin',
      'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36',
      'x-requested-with': 'XMLHttpRequest'
    },
    body: new URLSearchParams({
      'message': message,
      'name': name,
      'token': token
    })
  })
  .then(response => response.text())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
};

const stopLoopAfterTime = (loopId, time) => {
  setTimeout(() => {
    if (loops[loopId]) {
      clearInterval(loops[loopId]);
      delete loops[loopId];
      console.log(`Loop ${loopId} automatically stopped after ${time / 1000} seconds`);
    }
  }, time);
};

const replaceRandomWords = (message, randomWords) => {
  let newMessage = message;
  while (newMessage.includes('{rand}') && randomWords.length > 0) {
    const randomWord = randomWords[Math.floor(Math.random() * randomWords.length)];
    newMessage = newMessage.replace('{rand}', randomWord);
  }
  return newMessage;
};

app.post('/start', async (req, res) => {
  const { message, urls, tokens, loopId, isSingleMessage, randomWords } = req.body;

  try {
    const namePromises = urls.split(',').map(async url => {
      const response = await fetch(url.trim());
      const text = await response.text();
      const dom = new JSDOM(text);
      return dom.window.document.querySelector("#generate_form_box > div.secret_form > div > h1").textContent;
    });

    const names = await Promise.all(namePromises);

    if (isSingleMessage) {
      tokens.forEach((token, index) => postData(replaceRandomWords(message, randomWords), names[index], token));
      res.send(`Single message sent successfully`);
    } else {
      if (!loops[loopId]) {
        loops[loopId] = setInterval(() => {
          tokens.forEach((token, index) => postData(replaceRandomWords(message, randomWords), names[index], token));
        }, 10);
        stopLoopAfterTime(loopId, 10000000);
        res.send(`Loop ${loopId} started and will stop after 100 seconds`);
      } else {
        res.send(`Loop ${loopId} is already running`);
      }
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Failed to fetch the name from the URL');
  }
});

app.post('/stop', (req, res) => {
  const { loopId } = req.body;

  if (loops[loopId]) {
    clearInterval(loops[loopId]);
    delete loops[loopId];
    res.send(`Loop ${loopId} stopped`);
  } else {
    res.send(`Loop ${loopId} is not running`);
  }
});

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
